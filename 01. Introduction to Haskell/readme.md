# Въведение в Haskell - 16.02.2026

## Езикът `Haskell`

Накратко за Haskell:

  - функционален език за програмиране;
  - *статично* и *силно* типизиран;
  - използва *лениво* оценяване (lazy evaluation); нарича се още *нормална* стратегия на оценяване;
  - променливите са *неизменяеми* (immutable) по подразбиране;
  - функциите са *чисти* (pure), т.е. нямат *странични ефекти* (side effects);
  - всичко в Haskell е *израз* (връща резултат).

### Типове данни

- `Int` - цяло число в интервала [-9223372036854775808, 9223372036854775807]
- `Integer` - цяло число с произволна големина; по-неоптимално спрямо `Int`
- `Float` - дробно число с единична прецизност
- `Double` - дробно число с двойна прецизност
- `Bool` - булева стойност
- `Char` - UTF8 символ
- `String` - низ; същото е като списък от символи `[Char]`
- `[Int]`, `[Char]`, `[Integer]`, `[[Int]]`, `...` - списъци; хомогенни - т.е. елементите винаги са от един и същи тип
- `(Int, Char)`, `(Int, Int, Int)`, `...` - наредени n-торки; различните компоненти могат да бъдат от различен тип, но броят им е фиксиран

и други, за които ще говорим по-нататък.

### Аритметични оператори и функции

- `+`, `-`, `*`, `/`, `^`, `^^`, `**`, `div`, `quot`, `rem`, `mod`, `negate`, `abs`, `signum`, `fromIntegral`, ...

*Съвет*: За да видите повече информация за дадената функция,
може да напишете `:i(nfo) <function>` или `:t(ype) <function>` в GHCi.

### Логически оператори

- `<`, `>`, `<=`, `>=`, `==`, `/=`, `&&`, `||`

*Забележка*: Няма оператор за отрицание `!`. За целта се използва функцията `not`.

### Функции

Всяка функция приема `n` на брой аргументи и връща някакъв резултат.
От това следва, че и типът на дадена функция се състои от тези 
`n+1` на брой типа, разделени със стрелки `->`:

```hs
add :: Int -> Int -> Int  -- тип на функция
add x y = x + y  -- дефиниция на функцията
```

Защо се използват стрелки, ще разберем по-нататък в курса.

Операторът `::` се използва за указването на тип на някаква стойност/функция.

Аргументите на функцията се изброяват един след друг, разделени с празни места
(`add x y = ...`). От лявата част на равенството въвеждаме локални променливи (формални параметри),
с които се свързват фактическите параметри при извикването на функцията. От дясната част на
равенството пишем тялото на функцията - нейната дефиниция.

Операторът `=`, подобно на голяма част от езиците за програмиране, **не** се използва за
сравнения, а за дефиниции (може да си мислите, че това е в някакъв смисъл подобно на
инициализацията на константа в C++).

Забележете, че функциите в Haskell **винаги** връщат някакъв резултат.
Тоест, нямаме истински начин да напишем функция, която да връща `void`,
както например в C++.

В Haskell скобите се използват **единствено** за да указват приоритет
(или при частично прилагане на функции, както ще видим по-нататък в курса).
Например, в C++ бихме извикали функцията `add` по следния начин:

```cpp
int add(int x, int y) { return x + y; }
int z = add(10, 5);
```

Но в Haskell `add(10, 5)` би било грешно. Ако в C++ и повечето процедурни езици
скобите и запетаите служат за прилагането на функция върху някакви стойности,
то в Haskell това прилагане се постига само и единствено чрез едно или повече празни места (символът `' '`).
Тоест, горната функция бихме извикали като `add 10 5`. По-нататък в курса ще разберем
защо синтаксисът на функциите е дефиниран именно по този начин.

```hs
функция :: Float -> String
функция _ = "можем да използваме кирилица!"
```

```hs
greet :: String -> String
greet name = "Hello, " ++ name
```

В частност, можем да си мислим за константите (защо не е правилно да ги наричаме променливи?) `foo :: Int` като за 0-местни функции.

В Haskell прилагането на функции е с най-висок приоритет. Например, следният кодов фрагмент се оценява по този начин:

```hs
-- използваме функцията add от по-горе
ghci> add 10 8 + add 2 4  -- 18 + 6
24
```

### Условни конструкции

- if/else
```hs
length :: [a] -> Int
length l
  = if null l
      then 0
      else 1 + length (tail l)
```

- пазачи (guards)
```hs
length :: [a] -> Int
length l
  | null l    = 0
  | otherwise = 1 + length (tail l)
```

- напасване на образци (pattern matching)
```hs
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs
```

- разглеждане на случаи (case analysis)
```hs
length :: [a] -> Int
length l
  = case l of
      [] -> 0
      (_:xs) -> 1 + length xs
```

## Where-клаузи и let-bindings

И двете са начин да пишем локални дефиниции
в областта на някаква друга дефиниция:

```hs
foo :: Int -> Int
foo n = bar + baz * qux
  where
    bar = n * 10 + 20
    baz = n ^ 2
    qux = bar + baz
```

```hs
foo :: Int -> Int
foo n = let bar = n * 10 + 20
            baz = n ^ 2
            qux = bar + baz
          in bar + baz * qux
```
